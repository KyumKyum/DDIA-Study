
# 1주차 Chapter 2 (p27 ~ p42) 임규민


## 1. Introduction

> 자... 이것이 클릭이야...

개발에서 가장 중요한 것을 이야기하지만, 나는 아마도 "클릭"이라고 이야기를 할 것이다.
아니, 클릭을 해야지 개발이고 뭐고 할 수 있지 않는가! ~~물론 헤비 vim 유저는 제외~~

이와 같이 모든 것에는 *아주 기초가 되는 것*이 존재한다. 그리고, 그 기초가 되는 것은 모든 것에 뼈대가 되는, 아주 중요한 것이라고 책은 이야기를 한다.

개발의 가장 중요한 것이자 기초적인 것이 '클릭'이라고 이야기를 해보자. 그렇다면, **서비스의 개발**에 있어서 가장 중요한 것은 무엇일까?  DDID는 소프트웨어 개발에 있어서 가장 중요한 것은 바로 **데이터 모델을 표현하는 방법**이라고 이야기를 한다.


데이터를 표현하는 방법은 여러가지가 있다. 예를 들어, 필자인 '임규민'을 표현한다면, 정말 다양한 방법으로 표현을 할 수 있을 것이다.

- 애플리케이션 개발자로서는 '임규민'이라는 존재를 *API*로 표현 할 것이다.

```http
GET http://host:1234/v1/info?data=mbti
```

```json
{
  "response": {
    "mbti": "ENFJ"
  }
}
```


- 데이터 구조를 다루는 개발자는 JSON으로 '임규민'이라는 존재를 표현할 것이다.
```json
{
	"name": "임규민",
	"nickname": "Kyum Kyum",
	"current_position": {
	    "role": "Backend Developer",
	    "company": "Naver",
	    "since": "2025-07",
	    "department": "Portal Server"
  },
}
```

- 해당 데이터를 직접 데이터베이스에 저장하는 데이터베이스 개발자는 '임규민'이라는 존재를 다음과도 같이 표현할 것이다.

|position_id|user_id|role|company|since|department|
|---|---|---|---|---|---|
|1|1|Backend Developer|Naver|2025-07-01|Portal Server|

- 하드웨어 엔지니어는, 이 모든 것을 바이트로 표현할 것이다.
```text
01001001110100101010101.....
```

점점 밑으로 내려갈수록, 데이터의 구조와 생김새는 복잡해지고 이해하기 어려워진다. ~~만약 내 주변에 기계어를 이해할 수 있다고 이야기하는 사람이 있다면 일단 멀리 할 것이다.~~ 이를 통해 우리는 다음과 같은 사실을 이해할 수 있다.

> 계층이 올라갈수록, 더욱 명확한 데이터 모델을 제공해 하위 계층의 복잡성을 숨긴다!

이러한 것을 전문 용어로 **추상화**라고 한다. 상위 계층에서 추상화가 된 데이터는 하위 레이어의 데이터 표현(representation) 복잡성을 숨겨, 다른 그룹의 사람들이 더욱 효율적으로 일할 수 있게끔 한다.

그렇다면, 이러한 추론 역시 가능하다.

> 만약, 데이터 추상화를 개판으로 하면, 데이터의 이해도 역시 개판 5분전이 된다!

왜 DDID에서 데이터의 표현과 구현이 서비스 개발의 *기초*라고 하는지 이제 이해가 되는가? 데이터의 모델은 사람의 이해도를 넘어서 **서비스가 할 수 있는 일과 없는 일**에 대한 지대한 영향을 줌으로, 이 기초가 되는 작업은 **중요**하기도 하다.


## 2. 관계형 모델과 문서 모델

> 데이터 간에도 '관계성'을 중요하게 여기는 개발자 감수성

에드가 코드 (Edgar Codd)는 *관계형 데이터 모델*이라는 개념을 만들게 되었다. 이 모델은 다음과 같은 특징을 가지고 있다.

- 각 데이터는 서로 관계를 가지고 있고,
- 각 데이터는 순서 없는 tuple (row)의 모음집이다.

이 개념을 바탕으로 RDB가 만들어지게 된다. 사실, 당시에 대부분의 데이터는 이러한 관계형으로 표현할 수 있었기에, 항공사도, 은행도, 너도 나도 모두가 이러한 관계형으로 데이터를 표현하게 되었다.

하지만 데이터의 종류와 구성 요소가 지나치게 풍부해지면서, 데이터는 더 이상 관계형으로는 표현하기 힘들어지게 된다.

> 간단히 생각해보자. 인스타그램의 "공통 팔로워"를 어떻게 관계형으로 개발할 지 생각을 해보면 머리가 아파지는 것을 느낄 수 있다.

또한, 이러한 관계형 데이터는 일종의 *변화*가 필요하다. 우리는 데이터를 관계형으로 표현하기로 한거지, 실제로 데이터는 관계형이지 않기 때문이다. 이러한 차이를 **임피던스 불일치 (impedence mismatch)** 라고 하며, ORM와 같은 도구를 활용하여 이러한 불일치를 없애는 전환 계층이 필요하다.

> 한 글자 치기도 귀찮아서 alias 설정을 하는 개발자들에게 이 얼마나 귀찮은 일인가!!

그렇게 JSON과 문서 형식의, 비관계성 데이터 모델인 **NoSQL** 모델이 만들어지게 된다.
- 더욱 높은 쓰기 처리량을 지원하고,
- 더욱 뛰어난 확장성을 지원하고,
- 동적이고 풍부한 표현력으로 데이터를 표현할 수 있고 (e.g. JSON의 트리 구조),
- 무엇보다, 무료 오픈소스다!! ~~죽어랏 오라클~~


## 3. 다대일과 다대다 관계

> 그렇다고 해서 RDB가 죽은 것인가!

정답은, 당연히도, "아니다"! 관계형으로 데이터를 표현하기에 할 수 있는 것이 있다.

다시, *임규민*으로 예시를 들어보자.

> 아무리 희귀하다고 하지만, 전세계에 MBTI가 ENFJ인 사람이 *임규민* 한 사람 뿐일까?

당연히 전 세계에는 정말 많은 ENFJ들이 존재할 것이다. 여기서 그 모든 사람이 동일한 ENFJ라는 MBTI를 갖고 있다는 것을 어떻게 표현 할 것인가?

1. 일일이 평문으로 MBTI 필드를 ENFJ로 채워 넣는다.
2. MBTI 테이블에서 ENFJ 라는 값을 만든 뒤, ENFJ인 사람들은 해당 값을 참조할 수 있도록 한다.

입 아프게 이야기를 할 필요가 없다. 당연히 후자 아닌가!

이렇듯, 관계형 데이터베이스는 **다대일 (N:1)** 혹은 **다대다 (N:M)** 관계의 데이터에서 표현을 더욱 쉽게 할 수 있다. 이러한 데이터를 관계형으로 표현함으로서
- 데이터간 모호함이 줄어들게 되고,
- 데이터 변경 역시 쉬워지며
- 의도치 않은 데이터의 중복 역시 사라지게 된다. (이걸 전문 용어로 **정규화 (Normalization)** 과정이라고 한다.)

> 역시, 각자의 장단점이 있어~

각자의 장단점을 살리기 위해, 관계형의 데이터 표현과 NoSQL의 데이터 표현 모두를 사용하는 경우도 있는데, 이러한 개념을 **다중 저장소 지속성 (polygot persistence)** 라고 한다.s

